# 1 What compileTest.sh actually does
```
source_file="$1"
target_file="$2"

aarch64-linux-gnu-g++ -x c++ "$source_file" \
  -fsingle-precision-constant -O2 \
  -include lib/sylib.h1 \
  -L build/lib -l:sylib++.a \
  -o "$target_file"
```
# Line-by-line meaning
## ① Inputs
```
source_file="$1"   # input file
target_file="$2"   # output executable
```

The judge script calls this as:
```
compileTest.sh xxx.sy xxx.out
```

**Important:**
Here, $source_file is whatever the judge passes, not necessarily .sy.

## ② aarch64-linux-gnu-g++ -x c++

This means:

“Treat the input as C++ source code, regardless of filename.”

So this script expects $source_file to be valid C++.

This matches the original competition design:

* student compiler outputs C++

* judge compiles it with g++

## ③ -include lib/sylib.h1

Forces inclusion of the runtime header:

* declares getint, putint, etc.

* avoids #include in generated code

## ④ -fsingle-precision-constant

A SysY-specific flag:

ensures floating constants behave as required

important for correctness

## ⑤ -O2

Optimization at judge level, not your compiler’s -O1.

This is allowed and expected.

## ⑥ -L build/lib -l:sylib++.a

Links against:

* provided C++ runtime

* static library

# 2️ How the judge actually uses this script

From README.md, the flow is:
```
.sy testcase
   ↓ (your compiler)
generated code
   ↓ (compileTest.sh)
.out executable
   ↓
run & compare output
```

Key point:

The judge does NOT run your compiler directly.
It runs compileTest.sh, which must be able to compile whatever your compiler produces.

# 3️ Why this script works for others but conflicts with you
Original competitors:

* compiler output: C++

* script expects: C++

-x c++  correct

You:

* compiler output: ARM assembly (.s)

# 4️ How to use this script properly in your case
adapt compileTest.sh to assembly

Since your compiler outputs .s, your script should assemble, not compile C++.

Correct version for YOUR compiler
```
source_file="$1"
target_file="$2"

aarch64-linux-gnu-gcc -static "$source_file" \
  -L build/lib \
  -l:sylib++.a \
  -o "$target_file"

```
Why this is correct:

* $source_file = .s

* gcc understands assembly automatically
* static linking matches judge expectations
* runtime symbols resolve correctly


# 修改
将评测脚本test.cppnotcp 备份为test1.cpp并编译为test.o
将所有-x -c++换成-static

# Error 2
```bash
checking tests/functional/01_mm3.sy
tests/functional/01_mm3.sy 编译失败
/usr/lib/gcc-cross/aarch64-linux-gnu/13/../../../../aarch64-linux-gnu/bin/ld:tests/functional/01_mm3.sy: file format not recognized; treating as linker script
/usr/lib/gcc-cross/aarch64-linux-gnu/13/../../../../aarch64-linux-gnu/bin/ld:tests/functional/01_mm3.sy:1: syntax error
collect2: error: ld returned 1 exit status
```
Your current tests/compileTest.sh is:
```
source_file="$1"
target_file="$2"

aarch64-linux-gnu-gcc -static "$source_file" \
  -fsingle-precision-constant -O2 \
  -include lib/sylib.h1 \
  -L build/lib -l:sylib.a \
  -o "$target_file"

```
But $source_file is:tests/functional/01_mm1.sy

So gcc is doing:gcc 01_mm1.sy → ld
And ld can't process .sy fiile!

    **What MUST happen instead (required pipeline)**

Your compiler is not gcc, but ./build/compiler.
So the pipeline must be:
```
.sy
 ↓ (your compiler)
.s   (ARM assembly)
 ↓ (gcc)
executable
```

Right now, you are skipping the first step.

**The correct codegenTest.sh (THIS FIXES EVERYTHING)**

Replace tests/compileTest.sh (or codegenTest.sh) with this exact logic:
```
source_file="$1"     # tests/functional/xx.sy
target_file="$2"     # build/custom/functional/xx.out

mid_file_s="${target_file}.s"

# 1. run YOUR compiler: .sy → .s
./build/compiler -S -o "$mid_file_s" "$source_file"

# 2. assemble + link: .s → executable
aarch64-linux-gnu-gcc -static "$mid_file_s" \
  -L build/lib \
  -l:sylib.a \
  -o "$target_file"
```
* Remove these (wrong for ASM)
```
-x c++

-include lib/sylib.h1

passing .sy to gcc
```
* Why the original script looked different

Original competition pipeline:

.sy → C++ → g++


Your pipeline:

.sy → ASM → gcc